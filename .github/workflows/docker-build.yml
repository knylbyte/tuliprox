---
name: Docker Build & Push tuliprox

on:
  workflow_dispatch:
    inputs:
      target:
        description: "Final target stage (scratch-final, alpine-final, or debug)"
        required: false
        default: scratch-final
        type: choice
        options:
          - scratch-final
          - alpine-final
          - debug
  push:
    branches:
      - master
      - develop
      - 'feature/**'
      - 'bugfix/**'
      - 'hotfix/**'

concurrency:
  group: build-and-pusch-tuliprox
  cancel-in-progress: true

permissions:
  contents: write
  packages: write
  actions: write

env:
  GHCR_NS: ghcr.io/${{ github.repository }}
  DOCKERFILE: docker/Dockerfile

jobs:
  prebuilds:
    name: Ensure prebuilds exist
    runs-on: ubuntu-24.04
    outputs:
      need_build_tools: ${{ steps.check.outputs.need_build_tools }}
      archs: ${{ steps.arch.outputs.archs }}

    steps:
      - name: Step 1.1 - Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Step 1.2 - Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Step 1.3 - Set arch list
        id: arch
        shell: bash
        run: |
          set -euo pipefail
          echo "archs=linux-amd64 linux-arm64" >> "$GITHUB_OUTPUT"

      - name: Step 1.4 - Check prebuild availability (all archs)
        id: check
        shell: bash
        env:
          BUILD_TOOLS_IMAGE: ${{ env.GHCR_NS }}/tuliprox-build-tools
        run: |
          set -euo pipefail
          need_build_tools=false
          for a in ${{ steps.arch.outputs.archs }}; do
            if ! docker buildx imagetools inspect "${BUILD_TOOLS_IMAGE}:${a}" >/dev/null 2>&1; then
              need_build_tools=true
            fi
          done
          echo "need_build_tools=$need_build_tools" >> "$GITHUB_OUTPUT"

      - name: Step 1.5 - Summary (prebuild check)
        if: always()
        shell: bash
        run: |
          {
            echo "## 🧩 Prebuilds"
            if [[ "${{ steps.check.outputs.need_build_tools }}" == "true" ]]; then
              echo "⚠️ tuliprox-build-tools images missing for at least one architecture."
              echo "- A dedicated build job will run before the Docker build."
            else
              echo "✅ All required prebuilds already present."
            fi
            echo ""
            echo "### 📦 Tags checked"
            for a in ${{ steps.arch.outputs.archs }}; do
              echo "- \`${{ env.GHCR_NS }}/tuliprox-build-tools:${a}\`"
            done
          } >> "$GITHUB_STEP_SUMMARY"

  build-tools-prebuild:
    name: Build tuliprox-build-tools (if needed)
    needs: prebuilds
    if: needs.prebuilds.outputs.need_build_tools == 'true'
    runs-on: ubuntu-24.04

    steps:
      - name: Step 2.1 - Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Step 2.2 - Ensure prebuild workflow is running
        id: ensure
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          wf="docker-build-tuliprox-build-tools.yml"

          existing="$(gh run list --workflow "$wf" --limit 10 --json databaseId,status -q 'map(select(.status == "in_progress" or .status == "queued")) | .[0].databaseId')"
          if [[ -n "${existing:-}" && "${existing}" != "null" ]]; then
            echo "🔁 Found existing run #${existing} for $wf" >&2
            echo "run_id=${existing}" >> "$GITHUB_OUTPUT"
            echo "triggered=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "⏳ Triggering workflow: $wf" >&2
          gh workflow run "$wf"
          sleep 3

          run_id="$(gh run list --workflow "$wf" --limit 1 --json databaseId -q '.[0].databaseId')"
          if [[ -z "${run_id:-}" || "${run_id}" == "null" ]]; then
            echo "Failed to detect run for $wf" >&2
            exit 1
          fi

          echo "run_id=${run_id}" >> "$GITHUB_OUTPUT"
          echo "triggered=true" >> "$GITHUB_OUTPUT"

      - name: Step 2.3 - Wait for prebuild workflow
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          run_id="${{ steps.ensure.outputs.run_id }}"
          if [[ -z "${run_id:-}" ]]; then
            echo "No workflow run id returned" >&2
            exit 1
          fi
          echo "🔎 Waiting for run #${run_id} to finish" >&2
          gh run watch "$run_id" --exit-status

      - name: Step 2.4 - Verify tuliprox-build-tools tags
        shell: bash
        env:
          BUILD_TOOLS_IMAGE: ${{ env.GHCR_NS }}/tuliprox-build-tools
        run: |
          set -euo pipefail
          archs="${{ needs.prebuilds.outputs.archs }}"

          for i in $(seq 1 60); do
            missing=0
            for a in $archs; do
              docker buildx imagetools inspect "${BUILD_TOOLS_IMAGE}:${a}" >/dev/null 2>&1 || missing=1
            done
            if [[ $missing -eq 0 ]]; then
              echo "✅ All prebuild tags are available."
              exit 0
            fi
            echo "… waiting for prebuild tags to appear (try $i/60)"
            sleep 10
          done

          echo "❌ Timeout waiting for prebuild images" >&2
          exit 1

      - name: Step 2.5 - Summary (tuliprox-build-tools)
        if: always()
        shell: bash
        run: |
          archs="${{ needs.prebuilds.outputs.archs }}"
          {
            echo "## 🛠️ tuliprox-build-tools"
            echo ""
            if [[ "${{ steps.ensure.outputs.triggered }}" == "true" ]]; then
              echo "✅ Triggered workflow run #${{ steps.ensure.outputs.run_id }} to build missing images."
            else
              echo "🔁 Reused existing workflow run #${{ steps.ensure.outputs.run_id }} and waited for completion."
            fi
            echo ""
            echo "### 📦 Tags confirmed"
            for a in $archs; do
              echo "- \`${{ env.GHCR_NS }}/tuliprox-build-tools:${a}\`"
            done
          } >> "$GITHUB_STEP_SUMMARY"

  build:
    name: Build & Publish
    needs:
      - prebuilds
      - build-tools-prebuild
    runs-on: ${{ matrix.runner || 'ubuntu-24.04' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-24.04
            arch_tag: linux-amd64
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
            arch_tag: linux-arm64

    steps:
      - name: Step 2.1 - Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Step 2.2 - Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.platform }}

      - name: Step 2.3 - Set up Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ matrix.platform }}

      - name: Step 2.4 - Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # --- Read version from CHANGELOG.md ---
      - name: Step 2.5 - Read version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          ver="$(grep -Eom1 '^# [0-9]+\.[0-9]+\.[0-9]+' CHANGELOG.md | awk '{print $2}')"
          if [[ -z "${ver:-}" ]]; then
            echo "Failed to parse version from CHANGELOG.md" >&2
            exit 1
          fi
          echo "version=$ver" >> "$GITHUB_OUTPUT"

      # --- Decide plan and tags ---
      - name: Step 2.6 - Decide plan
        id: plan
        shell: bash
        run: |
          set -euo pipefail
          ref="${GITHUB_REF_NAME}"

          target_input="${{ github.event.inputs.target || '' }}"
          [[ -z "$target_input" ]] && target_input=""

          declare -a tags=()
          plan=""

          case "$ref" in
            master)
              target="scratch-final"
              tags+=("latest" "${{ steps.version.outputs.version }}")
              plan="master"
              ;;
            develop)
              target="both-dev"  # handled later: scratch + alpine
              tags+=("dev" "dev@${{ steps.version.outputs.version }}" "dev-slim" "dev-slim@${{ steps.version.outputs.version }}")
              plan="dev"
              ;;
            feature/*)
              target="alpine-final"
              name="${ref#feature/}"
              safe="$(echo "$name" | tr ' ' '-' | tr -cd '[:alnum:]._-' )"
              tags+=("feat@${safe}")
              plan="feature"
              ;;
            bugfix/*)
              target="alpine-final"
              name="${ref#bugfix/}"
              safe="$(echo "$name" | tr ' ' '-' | tr -cd '[:alnum:]._-' )"
              tags+=("bug@${safe}")
              plan="bugfix"
              ;;
            hotfix/*)
              target="alpine-final"
              name="${ref#hotfix/}"
              safe="$(echo "$name" | tr ' ' '-' | tr -cd '[:alnum:]._-' )"
              tags+=("hot@${safe}")
              plan="hotfix"
              ;;
            *)
              echo "Unsupported branch '$ref'." >&2
              exit 1
              ;;
          esac

          if [[ -n "$target_input" ]]; then
            target="$target_input"
          fi
          printf "%s\n" "${tags[@]}" > /tmp/tags.txt
          echo "plan=$plan" >> "$GITHUB_OUTPUT"
          echo "target=$target" >> "$GITHUB_OUTPUT"
          echo "tags_file=/tmp/tags.txt" >> "$GITHUB_OUTPUT"
          echo "resolved_branch=$ref" >> "$GITHUB_OUTPUT"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "dispatch_simulated=true" >> "$GITHUB_OUTPUT"
          else
            echo "dispatch_simulated=false" >> "$GITHUB_OUTPUT"
          fi

      # --- Detect new version (only to decide Release later; tagging happens after build) ---
      - name: Step 2.7 - Detect new version (master only)
        id: newver
        if: steps.plan.outputs.plan == 'master'
        shell: bash
        run: |
          set -euo pipefail
          ver="${{ steps.version.outputs.version }}"
          git fetch --tags --quiet
          if git rev-parse -q --verify "refs/tags/v${ver}" >/dev/null; then
            echo "is_new=false" >> "$GITHUB_OUTPUT"
          else
            echo "is_new=true" >> "$GITHUB_OUTPUT"
          fi

      # --- Build final (scratch or alpine) with CACHE ---
      - name: Step 2.8 - Build final (${{ matrix.platform }})
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE }}
          platforms: ${{ matrix.platform }}
          push: true
          build-args: |
            GHCR_NS=${{ env.GHCR_NS }}
            BUILDPLATFORM_TAG=${{ matrix.arch_tag }}
          target: ${{ steps.plan.outputs.target == 'both-dev' && 'scratch-final' || steps.plan.outputs.target }}
          tags: |
            ${{ env.GHCR_NS }}:temp-${{ steps.plan.outputs.plan }}-${{ matrix.arch_tag }}
          cache-from: |
            type=gha,scope=final-${{ steps.plan.outputs.plan }}-${{ matrix.arch_tag }}
            type=registry,ref=${{ env.GHCR_NS }}:temp-${{ steps.plan.outputs.plan }}-${{ matrix.arch_tag }}
          cache-to: |
            type=gha,mode=max,scope=final-${{ steps.plan.outputs.plan }}-${{ matrix.arch_tag }}

      # --- Dev: also build alpine variant with CACHE ---
      - name: Step 2.9 - Build dev alpine (${{ matrix.platform }})
        if: steps.plan.outputs.plan == 'dev'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE }}
          platforms: ${{ matrix.platform }}
          push: true
          build-args: |
            GHCR_NS=${{ env.GHCR_NS }}
            BUILDPLATFORM_TAG=${{ matrix.arch_tag }}
          target: alpine-final
          tags: |
            ${{ env.GHCR_NS }}:temp-dev-alpine-${{ matrix.arch_tag }}
          cache-from: |
            type=gha,scope=final-dev-alpine-${{ matrix.arch_tag }}
            type=registry,ref=${{ env.GHCR_NS }}:temp-dev-alpine-${{ matrix.arch_tag }}
          cache-to: |
            type=gha,mode=max,scope=final-dev-alpine-${{ matrix.arch_tag }}


      # --- Export PLAN/TAGS for manifests ---
      - name: Step 2.10 - Export PLAN/TAGS for manifests
        id: export
        shell: bash
        run: |
          set -euo pipefail

          # Read from existing plan step outputs
          PLAN="${{ steps.plan.outputs.plan }}"
          TAGS_FILE="${{ steps.plan.outputs.tags_file }}"

          if [[ -z "${PLAN}" ]]; then
            echo "PLAN is empty"; exit 1
          fi

          # Emit multi-line TAGS output directly (keeps your tag list logic)
          if [[ -n "${TAGS_FILE}" && -s "${TAGS_FILE}" ]]; then
            {
              echo "tags<<EOF"
              cat "${TAGS_FILE}"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          else
            # No tags computed -> empty (downstream job will no-op)
            echo "tags=" >> "$GITHUB_OUTPUT"
          fi

          # Emit PLAN (single-line)
          echo "plan=${PLAN}" >> "$GITHUB_OUTPUT"

          # Emit ARCHES used for manifests (keep in sync with your matrix)
          echo "arches=linux-amd64 linux-arm64" >> "$GITHUB_OUTPUT"

      # ---- Release & Cargo.toml bump AFTER successful build+manifest ----
      - name: Step 2.11 - Extract release notes (master only, new version)
        id: notes
        if: success() && steps.plan.outputs.plan == 'master' && steps.newver.outputs.is_new == 'true'
        shell: bash
        run: |
          set -euo pipefail
          ver="${{ steps.version.outputs.version }}"
          awk -v ver="$ver" '
            BEGIN{print_header=0}
            $0 ~ "^# "ver" " {print_header=1; print; next}
            print_header && $0 ~ "^# [0-9]+\\.[0-9]+\\.[0-9]+" {exit}
            print_header {print}
          ' CHANGELOG.md > release_notes.md
          echo "notes_file=$PWD/release_notes.md" >> "$GITHUB_OUTPUT"

      - name: Step 2.12 - Bump Cargo.toml + tag + release (master only, new version)
        if: success() && steps.plan.outputs.plan == 'master' && steps.newver.outputs.is_new == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          ver="${{ steps.version.outputs.version }}"

          update_file() {
            local f="$1"
            awk -v newv="$ver" '
              BEGIN{in_pkg=0}
              /^\[package\]/{in_pkg=1; print; next}
              /^\[/{in_pkg=0; print; next}
              in_pkg && /^version *= *"/{
                sub(/^version *= *".*"$/, "version = \"" newv "\""); print; next
              }
              {print}
            ' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
          }

          for f in Cargo.toml backend/Cargo.toml frontend/Cargo.toml shared/Cargo.toml; do
            [[ -f "$f" ]] && update_file "$f"
          done

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add Cargo.toml backend/Cargo.toml frontend/Cargo.toml shared/Cargo.toml || true
          git commit -m "chore(release): bump to v${ver} [skip ci]" || true
          git tag -a "v${ver}" -m "v${ver}"
          git push origin "HEAD:${GITHUB_REF_NAME}" --tags

          gh release create "v${ver}" --title "v${ver}" --notes-file "${{ steps.notes.outputs.notes_file }}"

      # --- Summary ---
      - name: Step 2.13 - Summary
        if: always()
        shell: bash
        run: |
          {
            echo "## 🧱 Build & Release Summary"
            echo ""
            echo "### 🔖 Version"
            echo "- From CHANGELOG: **${{ steps.version.outputs.version }}**"
            echo ""
            echo "### 🌿 Plan"
            echo "- Event: **${{ github.event_name }}**"
            echo "- Branch: **${{ steps.plan.outputs.resolved_branch || github.ref_name }}**"
            if [[ "${{ steps.plan.outputs.dispatch_simulated }}" == "true" ]]; then
              echo "- Workflow dispatch simulated branch execution for: **${{ steps.plan.outputs.resolved_branch }}**"
            fi
            echo "- Target: **${{ steps.plan.outputs.target }}**"
            echo ""
            echo "### 🧩 Prebuilds"
            echo "- Namespace: \`${{ env.GHCR_NS }}\`"
            echo "- Checked arch tags: linux-amd64 • linux-arm64"
            echo ""
            echo "### 🧷 Cache"
            echo "- GHA cache scopes per-arch/plan"
            echo "- Registry cache-from: temp per-arch images"
            echo ""
            echo "### 🏷️ Final tags"
            if [[ -s "${{ steps.plan.outputs.tags_file }}" ]]; then
              while IFS= read -r t; do
                echo "- \`${{ env.GHCR_NS }}:${t}\`"
              done < "${{ steps.plan.outputs.tags_file }}"
            else
              echo "↔️ No final tags."
            fi
            echo ""
            if [[ "${{ steps.plan.outputs.plan }}" == "master" ]]; then
              if [[ "${{ steps.newver.outputs.is_new }}" == "true" ]]; then
                echo "### 🚀 Release"
                echo "✨ Performed Cargo.toml bump, git tag and GitHub Release after successful build."
              else
                echo "### 🚀 Release"
                echo "↔️ No new version (tag exists)."
              fi
            fi
            echo ""
            echo "### 🧭 Platforms"
            echo "- linux/amd64 • linux/arm64"
          } >> "$GITHUB_STEP_SUMMARY"

  manifests:
    name: Manifests
    needs: build
    runs-on: ubuntu-24.04

    steps:
      # Keep login/buildx setup minimal and explicit
      - name: Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: GHCR Login
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # --- Create manifests ---
      - name: Step 3.1 - Create manifests
        id: create
        shell: bash
        run: |
          set -euo pipefail

          PLAN='${{ needs.build.outputs.plan }}'
          TAGS_INPUT='${{ needs.build.outputs.tags }}'
          ARCHES_INPUT='${{ needs.build.outputs.arches }}'

          # Parse multi-line list of tags and space-separated arches
          readarray -t TAGS <<< "$TAGS_INPUT"
          read -r -a ARCHES <<< "$ARCHES_INPUT"

          # No tags -> nothing to do
          if [[ ${#TAGS[@]} -eq 0 || -z "${TAGS[0]// }" ]]; then
            echo "No tags to publish"; exit 0
          fi

          make_manifest () {
            local tag="$1"
            local src=()

            # Build source list per architecture
            for arch in "${ARCHES[@]}"; do
              case "$tag" in
                dev-slim* )
                  # temp-dev-<arch>
                  src+=( "${GHCR_NS}:temp-dev-${arch}" )
                  ;;
                dev* )
                  # temp-dev-alpine-<arch>
                  src+=( "${GHCR_NS}:temp-dev-alpine-${arch}" )
                  ;;
                * )
                  # temp-<plan>-<arch>
                  src+=( "${GHCR_NS}:temp-${PLAN}-${arch}" )
                  ;;
              esac
            done

            echo "⛏️  Creating manifest ${GHCR_NS}:${tag}"
            docker buildx imagetools create -t "${GHCR_NS}:${tag}" "${src[@]}"
          }

          for t in "${TAGS[@]}"; do
            # Skip blank lines safely
            [[ -n "${t// }" ]] || continue
            make_manifest "$t"
          done

      # --- Final summary for the manifests ---
      - name: Summary (manifests)
        if: always()
        shell: bash
        run: |
          {
            echo "## 📚 Multi-arch manifests"
            echo ""
            if [[ "${{ steps.create.outcome }}" == "success" ]]; then
              echo "✅ All requested manifests were created."
            else
              echo "❌ Manifest creation encountered an error."
            fi
            echo ""

            echo "### 🏷️ Tags"
            # Reuse outputs for a user-friendly list
            TAGS_INPUT='${{ needs.build.outputs.tags }}'
            if [[ -n "$TAGS_INPUT" ]]; then
              while IFS= read -r line; do
                [[ -n "${line// }" ]] || continue
                echo "- \`${{ env.GHCR_NS }}:${line}\`"
              done <<< "$TAGS_INPUT"
            else
              echo "- (none)"
            fi

            echo ""
            echo "### 🧩 Architectures"
            for a in ${{ needs.build.outputs.arches }}; do
              echo "- ${a}"
            done

            echo ""
            echo "### 📦 Registry"
            echo "- ghcr.io"
          } >> "$GITHUB_STEP_SUMMARY"
